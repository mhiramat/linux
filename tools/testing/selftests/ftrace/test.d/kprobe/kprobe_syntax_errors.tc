#!/bin/sh
# SPDX-License-Identifier: GPL-2.0
# description: Kprobe event parser error check

[ -f kprobe_events ] || exit_unsupported # this is configurable

check_error() { # command expected_pos
echo "$1"
(! echo "$1" > kprobe_events ) >& /dev/null
if [ -f error_log ]; then
  grep "trace_kprobe: error:" -A 3 error_log
  N=$(tail -n 1 error_log | wc -c)
  # "  Command: " and "^" => 12
  test $(expr 12 + $2) -eq $N
  echo > error_log
fi
}


if grep -q 'r\[maxactive\]' README; then
check_error 'p100 vfs_read' 2		# MAXACT_NO_KPROBE
check_error 'r1a111 vfs_read' 2		# BAD_MAXACT
check_error 'r100000 vfs_read' 2	# MAXACT_TOO_BIG
fi

check_error 'p non_exist_func' 3	# BAD_PROBE_ADDR (enoent)
check_error 'p hoge-fuga' 3		# BAD_PROBE_ADDR (bad syntax)
check_error 'p hoge+1000-1000' 3	# BAD_PROBE_ADDR (bad syntax)
check_error 'r vfs_read+10' 3		# BAD_RETPROBE
check_error 'p:/bar vfs_read' 3		# NO_GROUP_NAME
check_error 'p:12345678901234567890123456789012345678901234567890123456789012345/bar vfs_read' 3	# GROUP_TOO_LONG

check_error 'p:foo.1/bar vfs_read' 3	# BAD_GROUP_NAME
check_error 'p:foo/ vfs_read' 7		# NO_EVENT_NAME
check_error 'p:foo/12345678901234567890123456789012345678901234567890123456789012345 vfs_read' 7	# EVENT_TOO_LONG
check_error 'p:foo/bar.1 vfs_read' 7	# BAD_EVENT_NAME

check_error 'p vfs_read $retval' 12	# RETVAL_ON_PROBE
check_error 'p vfs_read $stack10000' 12	# BAD_STACK_NUM

if grep -q '$arg<N>' README; then
check_error 'p vfs_read $arg10000' 12	# BAD_ARG_NUM
fi

check_error 'p vfs_read $none_var' 12	# BAD_VAR

check_error 'p vfs_read %none_reg' 12	# BAD_REG_NAME
check_error 'p vfs_read @12345678abcde' 12	# BAD_MEM_ADDR
check_error 'p vfs_read @+10' 12	# FILE_ON_KPROBE

check_error 'p vfs_read +0@0)' 12	# DEREF_NEED_BRACE
check_error 'p vfs_read +0ab1(@0)' 12	# BAD_DEREF_OFFS
check_error 'p vfs_read +0(+0(@0)' 17	# DEREF_OPEN_BRACE

if grep -A1 "fetcharg:" README | grep -q '\$comm' ; then
check_error 'p vfs_read +0($comm)' 15	# COMM_CANT_DEREF
fi

check_error 'p vfs_read &1' 12		# BAD_FETCH_ARG


# We've introduced this limitation with array support
if grep -q ' <type>\\\[<array-size>\\\]' README; then
check_error 'p vfs_read +0(+0(+0(+0(+0(+0(+0(+0(+0(+0(+0(+0(+0(+0(@0))))))))))))))' 15	# TOO_MANY_OPS?
check_error 'p vfs_read +0(@11):u8[10' 22	# ARRAY_NO_CLOSE
check_error 'p vfs_read +0(@11):u8[10]a' 26	# BAD_ARRAY_SUFFIX
check_error 'p vfs_read +0(@11):u8[10a]' 23	# BAD_ARRAY_NUM
check_error 'p vfs_read +0(@11):u8[256]' 23	# ARRAY_TOO_BIG
fi

check_error 'p vfs_read @11:unknown_type' 16	# BAD_TYPE
check_error 'p vfs_read $stack0:string' 20	# BAD_STRING
check_error 'p vfs_read @11:b10@a/16' 16	# BAD_BITFIELD

check_error 'p vfs_read arg123456789012345678901234567890=@11' 12	# ARG_NAME_TOO_LOG
check_error 'p vfs_read =@11' 12		# NO_ARG_NAME
check_error 'p vfs_read var.1=@11' 12		# BAD_ARG_NAME
check_error 'p vfs_read var1=@11 var1=@12' 21	# USED_ARG_NAME
check_error 'p vfs_read +1234567(+1234567(+1234567(+1234567(+1234567(+1234567(@1234))))))' 12	# ARG_TOO_LONG
check_error 'p vfs_read arg1=' 17		# NO_ARG_BODY

# instruction boundary check is valid on x86 (at this moment)
case $(uname -m) in
  x86_64|i[3456]86)
    echo 'p vfs_read' > kprobe_events
    if grep -q FTRACE ../kprobes/list ; then
	check_error 'p vfs_read+3' 3		# BAD_INSN_BNDRY (only if function-tracer is enabled)
    fi
    ;;
esac

exit 0
